---
title: Output Router
description: MIME type-based output dispatcher for Jupyter outputs
icon: Route
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';

Automatically selects the best renderer for Jupyter outputs based on MIME type priority. Routes to the appropriate output component (AnsiOutput, MarkdownOutput, HtmlOutput, ImageOutput, SvgOutput, or JsonOutput) based on content type.

## Installation

<Tabs items={['CLI', 'Manual']}>
  <Tab value="CLI">
    ```bash
    npx shadcn@latest add https://nteract.io/r/output-router.json
    ```
  </Tab>
  <Tab value="Manual">
    Install all output component dependencies, then copy from [the registry source](https://github.com/nteract/elements/blob/main/registry/outputs/output-router.tsx).
  </Tab>
</Tabs>

<Callout type="info">
  OutputRouter depends on all other output components. Installing it will also install AnsiOutput, MarkdownOutput, HtmlOutput, ImageOutput, SvgOutput, and JsonOutput.
</Callout>

## Usage

```tsx
import { OutputRouter } from "@/registry/outputs/output-router"

export function Example() {
  // Jupyter output data with multiple MIME types
  const outputData = {
    "text/plain": "Hello, World!",
    "text/html": "<b>Hello, World!</b>"
  }
  
  // OutputRouter will select text/html (higher priority)
  return <OutputRouter data={outputData} />
}
```

### With Metadata

Metadata is keyed by MIME type, same as data. Used for image dimensions, JSON display settings, etc:

```tsx
<OutputRouter
  data={{
    "image/png": "iVBORw0KGgoAAAANSUhEUgAAAAEAAAAB..."
  }}
  metadata={{
    "image/png": { width: 400, height: 300 }
  }}
/>
```

## Props

| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `data` | `Record<string, unknown>` | — | Output data mapping MIME types to content |
| `metadata` | `Record<string, object>` | `{}` | Metadata mapping MIME types to their settings |
| `unsafe` | `boolean` | `false` | Allow unsafe HTML rendering (requires iframe) |
| `fallback` | `ReactNode` | — | Custom fallback when no MIME type is supported |
| `loading` | `ReactNode` | — | Custom loading component while lazy-loading |
| `className` | `string` | `""` | Additional CSS classes |

## Metadata

Metadata is passed through to the appropriate output component:

| MIME Type | Metadata | Usage |
| --- | --- | --- |
| `image/*` | `{ width, height }` | Image dimensions |
| `application/json` | `{ collapsed }` | JSON tree collapse depth |

## MIME Type Priority

OutputRouter selects renderers based on this priority order:

| Priority | MIME Type | Renderer |
| --- | --- | --- |
| 1 | `application/vnd.jupyter.widget-view+json` | (widgets not yet supported) |
| 2 | `application/vnd.plotly.v1+json` | JsonOutput |
| 3 | `application/vnd.vegalite.v*+json` | JsonOutput |
| 4 | `application/geo+json` | JsonOutput |
| 5 | `text/html` | HtmlOutput |
| 6 | `text/markdown` | MarkdownOutput |
| 7 | `image/svg+xml` | SvgOutput |
| 8 | `image/png`, `image/jpeg`, etc. | ImageOutput |
| 9 | `application/json` | JsonOutput |
| 10 | `text/plain` | AnsiOutput |

## Jupyter Integration

OutputRouter is designed to work directly with Jupyter output messages:

```tsx
import { OutputRouter } from "@/registry/outputs/output-router"

function CellOutput({ output }) {
  // execute_result and display_data outputs
  if (output.output_type === "execute_result" || 
      output.output_type === "display_data") {
    return <OutputRouter data={output.data} metadata={output.metadata} />
  }
  
  // stream outputs (stdout/stderr)
  if (output.output_type === "stream") {
    return <OutputRouter data={{ "text/plain": output.text }} />
  }
  
  return null
}
```

## Lazy Loading

Components are lazy-loaded for better bundle splitting. A loading spinner is shown while components load. You can customize this:

```tsx
<OutputRouter
  data={outputData}
  loading={<div>Loading...</div>}
/>
```

## Fallback

When no supported MIME type is found:

```tsx
<OutputRouter
  data={{}}
  fallback={<div>No output to display</div>}
/>
```

## Unsafe Mode

For HTML and Markdown outputs that contain scripts, use `unsafe={true}`. This requires rendering inside an iframe:

```tsx
// Inside a sandboxed iframe only
<OutputRouter data={outputData} unsafe={true} />
```

## Helper Function

Use `getSelectedMimeType` to inspect which MIME type would be selected:

```tsx
import { getSelectedMimeType } from "@/registry/outputs/output-router"

const mimeType = getSelectedMimeType({
  "text/plain": "Hello",
  "text/html": "<b>Hello</b>"
})
// Returns: "text/html"
```
